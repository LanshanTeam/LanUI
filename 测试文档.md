😍😍 测试 🤤🤤 我的测试 🤤
<a name="exJD8"></a>

# jest 断言

<a name="JqVBk"></a>

## 基础知识

1. test 用于定义单个的用例，与此类似的有 describe 和 it，describe 表示一组分组，其中可以包含多个 test，而 it 是 test 的别名，有相同的作用

```typescript
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import App from './App';

describe('test', () => {
    test('first unit test', () => {
        render(<App />);
        expect(screen.getByText('Vite + React')).toBeInTheDocument();
    });
});
```

-   如上，在 describe 的回调中可以包含多组 test。在这个单测中我们判断了 vite+react 是否在我们的 DOM 中，`screen.getByText`用于元素的查找。
-   再看这行代码`expect(screen.getByText("Vite + React")).toBeInTheDocument();`，表示的是期望(expect)`screen.getByText("vite + react")`这个元素`toBeInTheDocument`(可以在页面正文)
-   稍微总结一下，expect 其中的参数填入你需要进行判断的对象，`toBeInTheDocument`这个 api 是匹配器。也称断言，用来告诉程序你的预期是什么，通过对预期的对象进行断言就是单元测试的基本原理

2. 常见断言场景
   | **场景方向** | 涉及的断言 Api |
   | --- | --- |
   | 基础类型的比较 | ` not``toBe(value) `<br />`toBeTruthy(value)`<br />`toBeDefined()`<br />`toBeUndefined()`<br />`toBeCloseTo(value)`<br />`toBeNaN()` |
   | 引用类型的比较 | `toEqual(value)` |
   | 数字符号 | `**toBeGreaterThan(value)** `<br />`toBeLessThan(value) `<br />`toBeGreaterThanOrEqual(value)`<br /> `toBeLessThanOrEqual(value)` |
   | 正则匹配 | `toMatch(value) `<br />`toMatchObject(value)` |
   | 表单验证 | `toContain(value) `<br />`arrayContaining(value) `<br />`toContainEqual(value) `<br />`toHaveLength(value) `<br />`toHaveProperty(value)` |
   | 错误抛出 | `toThrow() `<br />`toThrowError()` |

<a name="EWRr2"></a>

## 基础类型的比较

1. 常规用法

-   `toBe`：在基础类型中，大部分比较都可以通过 toBe 来完成，包括 booolean 和 undefined

```typescript
test('基础类型的比较', () => {
    // tobe
    expect(1 + 1).toBe(2);
    // not，not用来表示非的判断
    expect(1 + 1).not.toBe(3);
});
```

也可以对函数返回的类型进行判断

```typescript
import React from 'react';
test('基础类型的比较', () => {
    const test = () => {
        console.log('wujiayu');
    };
    expect(test()).toBe(undefined);
});
```

需要注意的是，toBe 无法对浮点类型进行断言，应该使用`toBeCloseTo()`,这个断言用来判断对象和预期的精度是否足够接近，而不再是全等
<a name="uvI8G"></a>

## 引用类型的断言

`toEqual`：`toEqual`会深度递归对象的每个属性，进行深度比较，只要原始值相同，就可以通过断言

```typescript
test('引用类型的比较', () => {
    const a = {
        obj1: {
            name: 'obj1',
            obj2: {
                name: 'obj2',
            },
        },
    };
    const b = Object.assign(a); // 浅
    const c = JSON.parse(JSON.stringify(a)); // 深

    expect(a).toBe(b); // √
    expect(a).not.toBe(c); // √
    expect(a).toEqual(b); // √
    expect(a).toEqual(c); // √
});
```

注：toEqual 也可以用于基础类型的比较
<a name="I8HVw"></a>

## 数字符号的断言

```typescript
test('数字符号的断言', () => {
    // <
    expect(2).toBeLessThan(3); // 其它符号同理
});
```

<a name="PTmaF"></a>

## 正则匹配

```typescript
test('正则匹配', () => {
    expect('this is a regexp').toMatch(/regexp/);
    const obj = { prop1: 'test', prop2: 'regexp validation' };
    const childObj = { prop1: 'test' };
    expect(obj).toMatchObject(childObj);
});
```

-   `toMatch(regexp)`会匹配字符串是否能够满足正则的验证
-   `toMatchObject(value)`用来验证对象能否包含 value 的全部属性，即 value 是否是匹配对象的子集
    <a name="RdBWg"></a>

## 表单验证

-   `toContain(value)`：判定某个值是否存在在数组中
-   `arrayContaining(value)`：匹配接收到的数组，与 toEqual 结合使用可以用于判定某个数组是否是另一个数组的子集
-   `toContainEqual(value)`：用于判定某个对象元素是否在数组中
-   `toHaveLength(value)`： 断言数组的长度
-   `toHaveProperty(value)`：断言对象中是否包含某个属性，针对多层级的对象可以通过 xx.yy 的方式进行传参断言

```typescript
test('表单验证', () => {
    // 数组元素验证
    expect([1, 2, 3]).toContain(1); // 判断某个值是否存在数组中
    expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 2])); // 与toEqual结合使用可以判定某个数组是否是另一个数组的子集
    expect([{ a: 1, b: 2 }]).toContainEqual({ a: 1, b: 2 }); // 用于判定某个对象元素是否在数组中
    // 数组长度
    expect([1, 2, 3]).toHaveLength(3); // 断言数组的长度
    // 对象属性验证
    const testObj = {
        prop1: 1,
        prop2: {
            child1: 2,
            child2: 'test',
        },
    };
    expect(testObj).toHaveProperty('prop1'); // 断言某个对象是否含有某个属性
    expect(testObj).toHaveProperty('prop2.child1'); // 针对多层级的对象可以使用xx.yy的方式进行传参断言
});
```

<a name="QOS5t"></a>

## 错误抛出

```typescript
// 存在toThrowError()和toThrow()两个匹配器，用法一样，可以理解为另一个别名
test('错误捕获', () => {
    const throwError = () => {
        const err = new Error('error: cqupt is door');
        throw err;
    };
    expect(throwError).toThrowError();
    expect(throwError).toThrow();

    const catchError = () => {
        try {
            const err = new Error('console err: this is a test error!');
            throw err;
        } catch (err) {
            console.log(err);
        }
    };
    expect(catchError).not.toThrow();
    expect(catchError).not.toThrowError();
});
```

<a name="eGfFd"></a>

## 实现自定义的断言

使用 extend，一个简单的 demo：

```typescript
test('同步自定义匹配器', () => {
    const toBeBetweenZeroAndTen = (num: number) => {
        if (num >= 0 && num <= 10) {
            return {
                message: () => '',
                pass: true,
            };
        } else {
            return {
                message: () =>
                    'expected num to be a number between zero and ten',
                pass: false,
            };
        }
    };
    expect.extend({
        toBeBetweenZeroAndTen,
    });
    expect(8).toBeBetweenZeroAndTen();
    expect(11).not.toBeBetweenZeroAndTen();
});
```

<a name="KIwWn"></a>

# DOM 查询：页面元素的渲染和行为查询

<a name="b0ufs"></a>

## 页面元素的渲染

<a name="G9rOl"></a>

### render

-   render 用于元素的渲染，并且在 render 执行之后会把值注入到 screen 对象中，如同上面第一个例子

```typescript
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom';
import App from './App';

describe('test', () => {
    test('first unit test', () => {
        render(<App />);
        expect(screen.getByText('Vite + React')).toBeInTheDocument();
    });
});
```

-   render 函数需要放在每个独立的 test 中，因为在每个 test 执行完以后，library 会调用 cleanup 方法来清理环境
    <a name="SHYpW"></a>

## 页面元素的查询

1. 分类：getBy getAllBy; queryBy queryAllBy; findBy findAllBy;
2. 不同点：

-   Get：返回查询的匹配节点，如果没有元素匹配则会报错(针对单查如果查到多个也会报错)
-   Query：返回查询的匹配节点，如果没有元素匹配会返回 null，但是不会报错(同样针对单查，如果查到多个匹配元素也会报错)
-   Find：返回一个 Promise，默认超时时间为 1000ms，如果没有元素匹配或者查找超时，Promise 状态切为 reject(同样针对单查，如果查到多个元素，也会返回 reject)

3. 当某个元素的存在并不决定这个用例能不能通过，那就使用 query；如果某个元素不存在，后续的步骤就没有执行的意义，那就使用 get 来直接中断这个用例
4. 例子

```typescript
import { FC } from 'react';

interface IProps {}

export const DomQuery: FC<IProps> = ({}) => {
    return (
        <div>
            <div>test1</div>
            <div>test2</div>
        </div>
    );
};
```

```typescript
import React from 'react';
import { render, screen } from '@testing-library/react';
import { DomQuery } from '../components/DomQuery';

describe('tests for', () => {
    test('get & query & find', () => {
        render(<DomQuery />);
        const element = screen.getByText(/test/i); // 报错：找到多个元素
        screen.debug(element);
    });
});
```

screen.debug 是暴露出来的一个调试 api，可以将查询出来的元素在控制台上显示
<a name="EPGsy"></a>

# DOM 查询：页面元素的参照物查询和优先级

<a name="GjrQJ"></a>

## 按照参照物分类

<a name="Uaxn2"></a>

### role ARIA

-   比如 div、button 等标签，即使没有加任何属性，也有一个隐形的 ARIA role 属性来表示它的语义。
    | 标签 | 隐形 ARIA role |
    | --- | --- |
    | a ,href | link |
    | a(无 href) body div span | generic |
    | form | form |
    | h1-h6 | heading |
    | html | document |
    | img | img |
    | p | paragraph |
    | table | table |
    | ul | list |
    | li | listitem |

aria 与 role 配合使用

```typescript
function App() {
    return (
        <div>
            <button aria-pressed>wujiayu</button>
        </div>
    );
}

export default App;
```

```typescript
import Button from '../App';
import { render, screen } from '@testing-library/react';

test('test role', () => {
    render(<Button />);
    const button = screen.getByRole('button', { pressed: true });
    screen.debug(button);
});
```

-   aria 属性用来表示对应角色下的额外特殊含义，可以在多个相同角色找那个选中我们需要的一个

`aria-hidden`:不在 DOM 树上访问的元素<br />`aria-selected`:元素是否被选中<br />`aria-checked`：元素是否被勾选<br />`aria-current`：当前选中的元素<br />`aria-pressed`：被按压的元素<br />`aria-expanded`：元素是否被展开<br />`aria-level`：区域的等级，h1-h6 会有默认的 aria-level 属性，值对应 1-6<br />`aria-describedby`：可以通过描述来定位额外的元素

-   例子

```typescript
function App() {
    return (
        <div>
            <button aria-describedby="description">
                <div id="description">自定义aria按钮</div>
            </button>
        </div>
    );
}

export default App;
```

```typescript
import Button from '../App';
import { render, screen } from '@testing-library/react';

test('test role', () => {
    render(<Button />);
    const button = screen.getByRole('button', {
        description: '自定义aria按钮',
    });
    screen.debug(button);
});
```

-   筛选项：name；通过这个和 aria-label 搭配使用筛选出我们需要的内容

```typescript
import { FC } from 'react';

interface IProps {}

export const DomQuery: FC<IProps> = ({}) => {
    return (
        <div>
            <div aria-label="test_note">1234</div>
        </div>
    );
};
```

```typescript
import React from 'react';
import { render, screen } from '@testing-library/react';
import { DomQuery } from '../components/DomQuery';

describe('tests for', () => {
    // ...
    test('aria-label', () => {
        render(<DomQuery />);
        const note = screen.getByRole('generic', { name: 'test_note' });
        screen.debug(note);
    });
});
```

<a name="gTCt3"></a>

## 其它参照物

-   标签文本：针对 label 标签的 text 查询

`const label = screen.getByLabelText("testLabel") `

-   占位符文本(placeholdertext):通过 placeholder 来查询

`**const** placeholderInput = screen.**getByPlaceholderText**( "a query by placeholder" );`

-   表单 value(displayValue):根据表单元素的值来查询

`const valueInput = screen.getByDisPlayValue("a query by value")`
<a name="OnZf6"></a>

## 查询的优先级

-   主动使用：getByRole、getByLabelText 等
-   考虑使用：getByAltText、getByTitle 等
-   尽量不用：getByTestId 等
